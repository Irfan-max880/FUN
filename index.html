<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shukku Runner — Endless Game</title>
<style>
  :root{--bg1:#05020a;--bg2:#071226;--accent:#ffd66b}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),#071126);font-family:Inter,system-ui,Arial;}
  #gameWrap{display:flex;align-items:center;justify-content:center;height:100vh;padding:12px;box-sizing:border-box;}
  canvas{background:transparent;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.6);max-width:100%;height:auto;}
  #ui{position:absolute;left:18px;top:18px;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.7)}
  #score{font-size:18px;font-weight:700}
  #coins{font-size:14px;opacity:.9}
  #gameOver{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);color:#fff;font-size:20px;z-index:50;flex-direction:column;gap:12px;visibility:hidden}
  .btn{background:linear-gradient(180deg,#ff7b7b,#ff4b4b);padding:10px 18px;border-radius:10px;border:none;color:white;font-weight:700;cursor:pointer}
  .hint{position:fixed;right:18px;top:18px;color:#fff;opacity:.9}
  @media (max-width:520px){#ui{left:10px;top:10px} .btn{padding:8px 12px}}
  .nameLabel{position:fixed;left:50%;transform:translateX(-50%);top:8px;color:#fff;font-weight:700;text-shadow:0 2px 8px rgba(0,0,0,.8);z-index:40}
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game" width="1100" height="520"></canvas>
</div>

<div id="ui">
  <div id="score">Score: 0</div>
  <div id="coins">Coins: 0</div>
</div>
<div class="hint">Tap / Space to jump — mobile friendly</div>
<div class="nameLabel">Shukku</div>

<div id="gameOver">
  <div style="font-size:32px;font-weight:800">Game Over</div>
  <div id="finalScore">Score: 0</div>
  <button id="restartBtn" class="btn">Restart</button>
</div>

<script>
/*
  Placeholder build: the game works immediately with a simple placeholder sprite.
  To use Shukku's actual image:
  1) Convert your PNG/JPG to a data URL (base64). Example tools: online "image to base64" or command-line:
     base64 image.png -> then prepend "data:image/png;base64,"
  2) Replace PLAYER_IMG_SRC = '' below with the full data URL string:
     const PLAYER_IMG_SRC = "data:image/png;base64,iVBORw0K...";
  That's it — save file and upload to GitHub Pages.
*/

/* ---------- CONFIG ---------- */
const PLAYER_IMG_SRC = ''; // <<-- currently empty => in-game placeholder used. Replace with data URL to embed your image.
const CANVAS_W = 1100, CANVAS_H = 520;

/* ---------- SETUP ---------- */
const canvas = document.getElementById('game');
canvas.width = CANVAS_W; canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');

let last = 0, dt = 0, running = true;
let score = 0, coinsCollected = 0;
const scoreEl = document.getElementById('score');
const coinsEl = document.getElementById('coins');
const gameOverEl = document.getElementById('gameOver');
const finalScoreEl = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');

/* ---------- AUDIO (WebAudio synth loop - royalty-free vibe) ---------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx, masterGain;

function initAudio(){
  audioCtx = new AudioCtx();
  masterGain = audioCtx.createGain(); masterGain.gain.value = 0.12; masterGain.connect(audioCtx.destination);
  const padOsc = audioCtx.createOscillator();
  const padGain = audioCtx.createGain();
  padOsc.type = 'sine'; padOsc.frequency.value = 110;
  padOsc.connect(padGain); padGain.connect(masterGain); padGain.gain.value = 0.0015;
  padOsc.start();

  function schedulePluck(time){
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = 440 + Math.random()*150;
    g.gain.value = 0;
    osc.connect(g); g.connect(masterGain);
    osc.start(time);
    g.gain.setValueAtTime(0, time);
    g.gain.linearRampToValueAtTime(0.06, time+0.02);
    g.gain.exponentialRampToValueAtTime(0.001, time+0.6);
    osc.stop(time+0.8);
  }
  let t0 = audioCtx.currentTime + 0.1;
  for(let i=0;i<64;i++) schedulePluck(t0 + i*0.35);

  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.type='sine'; lfo.frequency.value = 0.06; lfoGain.gain.value = 30;
  lfo.connect(lfoGain);
  lfoGain.connect(padOsc.frequency);
  lfo.start();
}

/* ---------- RESOURCES ---------- */
const playerImg = new Image();
playerImg.crossOrigin = "anonymous";
playerImg.src = PLAYER_IMG_SRC;
playerImg.onload = ()=> { /* ok */ };

/* ---------- GAME ENTITIES ---------- */
const groundY = CANVAS_H - 80;
const gravity = 2300;
const player = { x: 180, y: groundY, w: 120, h: 160, vy:0, onGround:true, scale: 0.9, runAnim:0 };
const ghost = { x: 60, y: groundY, w: 140, h: 180, speed: 120 };
let obstacles = [], coins = [];
let spawnTimer = 0, coinTimer = 0, difficultyTimer = 0, gameSpeed = 420;

/* ---------- HELPERS ---------- */
function rand(a,b){ return a + Math.random()*(b-a); }
function rectIntersects(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

/* ---------- INPUT ---------- */
let inputJump = false;
window.addEventListener('keydown',(e)=>{ if(e.code==='Space' || e.code==='ArrowUp') inputJump = true; });
window.addEventListener('keyup',(e)=>{ if(e.code==='Space' || e.code==='ArrowUp') inputJump = false; });
canvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); inputJump = true; }, {passive:false});
canvas.addEventListener('touchend',(e)=>{ e.preventDefault(); inputJump = false; }, {passive:false});
canvas.addEventListener('mousedown',(e)=>{ inputJump = true; });
canvas.addEventListener('mouseup',(e)=>{ inputJump = false; });

/* ---------- BACKGROUND DRAW (Demon Slayer-ish night forest) ---------- */
function drawBackground(t){
  const g = ctx.createLinearGradient(0,0,0,CANVAS_H);
  g.addColorStop(0,'#071022');
  g.addColorStop(0.6,'#071126');
  g.addColorStop(1,'#02040b');
  ctx.fillStyle = g; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

  ctx.beginPath(); ctx.fillStyle = 'rgba(255,252,220,0.85)';
  ctx.arc(CANVAS_W - 180,100,56,0,Math.PI*2); ctx.fill();

  const layers = [
    {count:6, scale:1.0, xOffset: (t*0.02)%CANVAS_W, col: 'rgba(2,6,12,0.85)'},
    {count:10, scale:0.7, xOffset: (t*0.04)%CANVAS_W, col: 'rgba(6,12,22,0.75)'},
    {count:16, scale:0.5, xOffset: (t*0.08)%CANVAS_W, col: 'rgba(8,16,28,0.65)'}
  ];
  for(let li=0;li<layers.length;li++){
    const L=layers[li];
    for(let i=0;i<L.count;i++){
      const sx = ((i*CANVAS_W/L.count) - L.xOffset + CANVAS_W*2) % (CANVAS_W + 300) - 150;
      const treeH = 160 * L.scale + (i%3)*20;
      drawTree(sx, groundY - treeH, 40*L.scale, treeH, L.col);
    }
  }

  ctx.fillStyle = '#071021'; ctx.fillRect(0, groundY, CANVAS_W, CANVAS_H-groundY);
  const mist = ctx.createLinearGradient(0,groundY,0,CANVAS_H);
  mist.addColorStop(0,'rgba(255,255,255,0.04)');
  mist.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle = mist; ctx.fillRect(0,groundY,CANVAS_W,80);
}
function drawTree(x,y,w,h,color){
  ctx.fillStyle = color; ctx.beginPath();
  ctx.moveTo(x, y+h);
  ctx.quadraticCurveTo(x - w*0.2, y + h*0.5, x - w*0.8, y + h*0.2);
  ctx.lineTo(x - w*0.5, y);
  ctx.lineTo(x + w*0.5, y);
  ctx.lineTo(x + w*0.8, y + h*0.2);
  ctx.quadraticCurveTo(x + w*0.2, y + h*0.5, x, y+h);
  ctx.fill();
}

/* ---------- SPAWN LOGIC ---------- */
function spawnObstacle(){
  const w = rand(36,72); const h = rand(36,110);
  obstacles.push({ x: CANVAS_W + 40, y: groundY - h, w, h });
}
function spawnCoin(){
  const size = 28;
  coins.push({ x: CANVAS_W + 40, y: groundY - rand(140,40), w:size,h:size, rot: Math.random()*Math.PI*2 });
}

/* ---------- DRAW COIN ---------- */
function drawCoin(c){
  ctx.save(); ctx.translate(c.x + c.w/2, c.y + c.h/2); ctx.rotate(c.rot);
  ctx.beginPath(); ctx.fillStyle = '#ffd66b'; ctx.ellipse(0,0,c.w/2,c.h/2,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#b86d00'; ctx.beginPath(); ctx.ellipse(0,0,c.w/2.8,c.h/2.8,0,0,Math.PI*2); ctx.fill(); ctx.restore();
}

/* ---------- DRAW GHOST (realistic scary stylized) ---------- */
function drawGhost(gst, t){
  ctx.save();
  const gx = gst.x, gy = gst.y, gw = gst.w, gh = gst.h;
  const bob = Math.sin(t*0.009 + gst.x*0.01)*6;
  ctx.translate(gx, gy + bob);
  ctx.beginPath();
  ctx.fillStyle = 'rgba(20,26,30,0.92)';
  ctx.ellipse(40, gh - 16, gw*0.38, 14, 0, 0, Math.PI*2);
  ctx.fill();

  const grad = ctx.createLinearGradient(0,0,gw,gh);
  grad.addColorStop(0,'rgba(230,240,250,0.95)');
  grad.addColorStop(1,'rgba(210,220,230,0.85)');
  ctx.fillStyle = grad;

  // rough realistic body (slightly torn)
  ctx.beginPath();
  ctx.moveTo(0,gh*0.35);
  ctx.bezierCurveTo(gw*0.2, -gh*0.8, gw*0.8, -gh*0.6, gw, gh*0.35);
  ctx.lineTo(gw, gh - 28);
  // ragged bottom
  for(let i=0;i<6;i++){
    const nx = gw*(i/5);
    const ny = gh - 8 + Math.sin(i*1.5 + gst.x*0.03)*8;
    ctx.quadraticCurveTo(nx + gw*0.05, ny+6, nx + gw*0.25, ny);
  }
  ctx.closePath();
  ctx.fill();

  // shadowy inner details
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = 'rgba(10,10,12,0.06)';
  ctx.beginPath();
  ctx.ellipse(gw*0.5, gh*0.5, gw*0.28, gh*0.18, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalCompositeOperation = 'source-over';

  // scary eyes / mouth
  ctx.fillStyle = 'rgba(10,10,10,0.98)';
  ctx.beginPath(); ctx.ellipse(gw*0.33, gh*0.45, 12, 22, -0.35, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(gw*0.65, gh*0.45, 12, 22, 0.35, 0, Math.PI*2); ctx.fill();

  // faint bluish glow
  ctx.strokeStyle = 'rgba(120,180,255,0.18)'; ctx.lineWidth = 6; ctx.stroke();
  ctx.restore();
}

/* ---------- DRAW PLAYER (placeholder or image if provided) ---------- */
function drawPlayer(p, t){
  const px = p.x, py = p.y - p.h;
  const bob = Math.sin(t*0.02 + p.runAnim)*6;
  // shadow
  ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.ellipse(px + p.w*0.45, groundY + 8, p.w*0.45, 12, 0, 0, Math.PI*2); ctx.fill();

  if(playerImg.src && playerImg.src.length > 10){
    // draw provided image with bottom crop to hide logos
    const sw = playerImg.naturalWidth, sh = playerImg.naturalHeight;
    const dw = p.w * p.scale, dh = p.h * p.scale;
    const rx = px, ry = py + bob - 10, rr = 14;
    ctx.save();
    roundRect(ctx, rx, ry, dw, dh, rr); ctx.clip();
    const imgRatio = sw/sh, destRatio = dw/dh;
    let sW = sw, sH = sh, sX=0, sY=0;
    if(imgRatio > destRatio){ sW = sh * destRatio; sX = (sw - sW)/2; } else { sH = sw / destRatio; sY = (sh - sH)/2; }
    const cropBottomPercent = 0.12; sH = sH * (1 - cropBottomPercent);
    ctx.drawImage(playerImg, sX, sY, sW, sH, rx, ry, dw, dh);
    ctx.restore();
  } else {
    // placeholder drawing (head + cloak + wand)
    ctx.save();
    const headX = px + p.w*0.45, headY = py + 48 + bob;
    // cloak
    ctx.fillStyle = '#0f0f14';
    roundRect(ctx, px + 8, py + 70 + bob, p.w - 16, p.h - 78, 18); ctx.fill();
    // wand
    ctx.save();
    ctx.translate(px + p.w - 18, py + 88 + bob); ctx.rotate(-0.3);
    ctx.fillStyle = '#8b5a2b'; ctx.fillRect(-6,-30,10,90);
    ctx.restore();
    // head
    ctx.beginPath(); ctx.fillStyle = '#f4c2c2'; ctx.ellipse(headX, headY, 28, 30, 0, 0, Math.PI*2); ctx.fill();
    // hair
    ctx.beginPath(); ctx.fillStyle = '#7b5a3a'; ctx.ellipse(headX, headY - 6, 34, 34, 0, 0, Math.PI*2); ctx.fill();
    // eyes
    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(headX-8, headY-4, 4,6,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(headX+8, headY-4, 4,6,0,0,Math.PI*2); ctx.fill();
    // name small
    ctx.fillStyle = 'white'; ctx.font = '600 16px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Shukku', px + p.w/2, py - 8 + bob);
    ctx.restore();
  }
}

/* ---------- UTIL ---------- */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
}

/* ---------- MAIN UPDATE ---------- */
function update(delta, t){
  if(!running) return;
  player.vy += gravity * delta;
  player.y += player.vy * delta;
  if(player.y >= groundY){ player.y = groundY; player.vy = 0; player.onGround = true; } else player.onGround = false;
  if(inputJump && player.onGround){ player.vy = -880; player.onGround = false; }

  const worldShift = gameSpeed * delta;
  for(let ob of obstacles) ob.x -= worldShift;
  for(let c of coins){ c.x -= worldShift; c.rot += delta * 6; }

  spawnTimer += delta;
  if(spawnTimer > Math.max(0.6, 1.6 - difficultyTimer*0.02)){ spawnTimer = 0; if(Math.random() > 0.35) spawnObstacle(); }
  coinTimer += delta;
  if(coinTimer > 0.9){ coinTimer = 0; if(Math.random() > 0.4) spawnCoin(); }

  obstacles = obstacles.filter(o => o.x + o.w > -40);
  coins = coins.filter(c => c.x + c.w > -40);

  for(let ob of obstacles){
    const hit = rectIntersects({x:player.x,y:player.y-player.h,w:player.w,h:player.h}, {x:ob.x,y:ob.y,w:ob.w,h:ob.h});
    if(hit){ score = Math.max(0, score - 12); ob.x += 80; }
  }

  for(let i=coins.length-1;i>=0;i--){
    const c = coins[i];
    if(rectIntersects({x:player.x,y:player.y-player.h,w:player.w,h:player.h}, {x:c.x,y:c.y,w:c.w,h:c.h})){
      coins.splice(i,1); coinsCollected++; score += 25;
    }
  }

  ghost.x += (gameSpeed * 0.2 + ghost.speed) * delta;
  difficultyTimer += delta; ghost.speed += delta * 2.5; gameSpeed += delta * 0.8 * (difficultyTimer*0.05);

  const distance = (player.x - ghost.x);
  if(distance < 80) endGame();

  score += 12 * delta;
  scoreEl.textContent = 'Score: ' + Math.floor(score);
  coinsEl.textContent = 'Coins: ' + coinsCollected;
}

/* ---------- DRAW ---------- */
function draw(t){
  drawBackground(t);
  for(let ob of obstacles){
    ctx.save(); ctx.fillStyle = '#2c2b3a'; ctx.translate(ob.x, ob.y); roundRect(ctx,0,0,ob.w,ob.h,8); ctx.fill(); ctx.restore();
  }
  for(let c of coins) drawCoin(c);
  drawPlayer(player, t);
  drawGhost(ghost, t);
  ctx.save(); ctx.globalAlpha = 0.08; ctx.fillStyle = '#000'; ctx.fillRect(8,8,180,60); ctx.restore();
}

/* ---------- LOOP ---------- */
function loop(now){
  if(!last) last = now;
  dt = (now - last)/1000; last = now;
  update(dt, now);
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  draw(now);
  if(running) requestAnimationFrame(loop);
}

/* ---------- END / RESTART ---------- */
function endGame(){
  running = false; gameOverEl.style.visibility = 'visible'; finalScoreEl.textContent = 'Score: ' + Math.floor(score);
  try{ if(audioCtx) audioCtx.suspend(); } catch(e){}
}
restartBtn.addEventListener('click', ()=>{
  obstacles = []; coins = []; spawnTimer = coinTimer = difficultyTimer = 0;
  ghost.x = 60; ghost.speed = 120; score = 0; coinsCollected = 0; gameSpeed = 420;
  player.y = groundY; player.vy = 0; running = true; gameOverEl.style.visibility = 'hidden'; last = 0;
  try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){}
  requestAnimationFrame(loop);
});

/* ---------- START ---------- */
document.addEventListener('click', function starter(){
  if(!audioCtx) initAudio();
  document.removeEventListener('click', starter);
}, {once:true});

requestAnimationFrame(loop);

/* ---------- NOTES ----------
 - To embed your actual image: replace PLAYER_IMG_SRC with the full data URL (starts with data:image/...)
 - If your photo shows logos at bottom, increase cropBottomPercent in drawPlayer to 0.18 or 0.22
 - Mobile: tap to jump. Desktop: Space/Up arrow.
 - Tweak speeds near top: gameSpeed, ghost.speed
--------------------------------*/
</script>
</body>
</html>
