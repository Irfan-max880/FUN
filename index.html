<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shukku — Stormy Ghost Shooter</title>
<style>
  :root{--ink:#000}
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,Arial}
  canvas{display:block;margin:auto;background:#000}
  #hud{position:fixed;left:16px;top:12px;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.7);font-weight:700;z-index:5}
  #hud .sub{font-weight:600;opacity:.9}
  #tip{position:fixed;right:16px;top:12px;color:#fff;opacity:.9;text-align:right;z-index:5}
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#fff;background:rgba(0,0,0,.55);gap:10px;visibility:hidden;z-index:10}
  .btn{background:#ff4b4b;border:none;color:#fff;padding:10px 16px;border-radius:10px;font-weight:800;cursor:pointer}
</style>
</head>
<body>
<canvas id="game" width="1100" height="520"></canvas>

<div id="hud">
  <div id="score">Score: 0</div>
  <div class="sub" id="kills">Ghosts banished: 0</div>
</div>
<div id="tip">Click or F to shoot • Space to hop</div>

<div id="overlay">
  <div style="font-size:34px;font-weight:900">Game Over</div>
  <div id="finalScore" style="font-size:18px">Score: 0</div>
  <button id="restart" class="btn">Restart</button>
</div>

<!-- Audio: storm ambience (loop) + thunder cracks -->
<audio id="ambience" loop preload="auto" muted>
  <source src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_38f2a26712.mp3?filename=heavy-rain-thunder-ambient-143076.mp3" type="audio/mpeg">
</audio>
<audio id="thunder" preload="auto">
  <source src="https://cdn.pixabay.com/download/audio/2021/10/26/audio_5eecac301e.mp3?filename=thunder-strike-110059.mp3" type="audio/mpeg">
</audio>

<script>
/* ====== Canvas + UI ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const killsEl = document.getElementById('kills');
const overlay = document.getElementById('overlay');
const finalScoreEl = document.getElementById('finalScore');
const restartBtn = document.getElementById('restart');

/* ====== Assets (your images) ====== */
const bgImg      = new Image(); bgImg.crossOrigin='anonymous';
bgImg.src        = "https://i.postimg.cc/L5tmbRTy/Screenshot-2025-0812-173844.png";

const playerImg  = new Image(); playerImg.crossOrigin='anonymous';
playerImg.src    = "https://i.postimg.cc/jdn1KZYb/Screenshot-20250812-001657-removebg-preview.png";

const enemyImg   = new Image(); enemyImg.crossOrigin='anonymous';
enemyImg.src     = "https://i.postimg.cc/vDwc43PK/Screenshot-2025-0812-174643-removebg-preview.png";

/* Debug logs to catch asset issues */
bgImg.onload=()=>console.log('BG loaded');
bgImg.onerror=()=>console.warn('BG failed to load');
playerImg.onload=()=>console.log('Player loaded');
playerImg.onerror=()=>console.warn('Player failed to load');
enemyImg.onload=()=>console.log('Ghost loaded');
enemyImg.onerror=()=>console.warn('Ghost failed to load');

/* ====== Game State ====== */
const GROUND_Y = 400;
let running = true;
let score = 0;
let kills = 0;

/* Player */
const player = { x:100, y:GROUND_Y, w:80, h:100, vy:0, jumping:false };

/* Enemies (front ghosts) */
let enemies = [];    // {x,y,w,h,speed,hp,alpha,dy,sway,state}
let spawnTimer = 0;
let spawnEvery = 120; // frames

/* Bullets */
let bullets = [];    // {x,y,w,h,spd}
let fireCooldown = 0;
const FIRE_COOLDOWN_FRAMES = 10;

/* Particles */
let particles = [];  // small sparks

/* Fog (procedural) */
let fogPuffs = [];   // {x,y,r,alpha,dx}
function initFog(){
  fogPuffs.length = 0;
  for(let i=0;i<60;i++){
    fogPuffs.push({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height,
      r: 80 + Math.random()*140,
      alpha: 0.06 + Math.random()*0.12,
      dx: -0.3 - Math.random()*0.4
    });
  }
}

/* Thunder & Lightning */
const ambience = document.getElementById('ambience');
const thunderSfx = document.getElementById('thunder');
let audioArmed = false;
function armAudio(){
  if (audioArmed) return;
  ambience.muted = false;
  ambience.volume = 0.6;
  ambience.play().then(()=>{ audioArmed = true; console.log('Ambience playing'); })
    .catch(e=>console.warn('Ambience blocked, will retry on next input', e));
}

let lightningTimer = 0;
let lightningFlash = 0; // 0..1 intensity
function scheduleLightning(){
  // randomize next lightning between 3–7 seconds
  lightningTimer = 180 + Math.floor(Math.random()*240);
}
scheduleLightning();

/* ====== Input ====== */
function shoot(){
  if (fireCooldown>0 || !running) return;
  bullets.push({ x: player.x + player.w, y: player.y + player.h/2 - 3, w:16, h:6, spd:10 });
  fireCooldown = FIRE_COOLDOWN_FRAMES;
}

document.addEventListener('keydown', e=>{
  armAudio();
  if ((e.code==='Space'||e.code==='ArrowUp') && !player.jumping && running){
    player.vy = -15; player.jumping = true;
  }
  if (e.code==='KeyF') shoot();
  if (e.code==='Enter' && !running) restart();
});
canvas.addEventListener('click', e=>{
  armAudio();
  if (running) shoot();
  else restart();
});

/* ====== Helpers ====== */
function rectOverlap(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
function spawnEnemy(){
  const h = 110 + Math.random()*30;
  enemies.push({
    x: canvas.width + 20,
    y: GROUND_Y + (Math.random()<0.2 ? -20 : 0), // mostly ground
    w: 90, h,
    speed: 1.4 + Math.random()*0.6, // slow creep
    hp: 2, alpha: 1,
    dy: 0, sway: Math.random()*Math.PI*2,
    state: 'alive'
  });
}
function explode(x,y,base=8){
  for(let i=0;i<base;i++){
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*3,
      vy: (Math.random()-1.2)*3,
      life: 28 + Math.random()*12
    });
  }
}

/* ====== Core Update/Draw ====== */
function update(){
  /* Score & cooldown */
  score += 0.12;
  if (fireCooldown>0) fireCooldown--;

  /* Spawn enemies (kept spaced) */
  spawnTimer++;
  if (spawnTimer >= spawnEvery){
    spawnTimer = 0;
    if (enemies.length===0 || enemies[enemies.length-1].x < canvas.width - 260){
      spawnEnemy();
    }
  }

  /* Player physics */
  player.y += player.vy;
  player.vy += 0.8;
  if (player.y >= GROUND_Y){ player.y = GROUND_Y; player.jumping = false; }

  /* Bullets */
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.spd;
    if (b.x > canvas.width+40) bullets.splice(i,1);
  }

  /* Enemies */
  for (let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if (!e) continue;

    if (e.state==='alive'){
      e.x -= e.speed;
      e.sway += 0.03;
      e.dy = Math.sin(e.sway)*0.6;

      // bullet hits
      for (let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        if (rectOverlap(b, {x:e.x+20,y:e.y-10+e.dy,w:e.w-40,h:e.h-20})){
          bullets.splice(j,1);
          e.hp -= 1;
          explode(b.x, b.y, 6);
          if (e.hp<=0){
            e.state = 'fading';
            e.speed = 0.4;
          }
        }
      }

      // reached player?
      if (rectOverlap(
        {x:player.x, y:player.y, w:player.w, h:player.h},
        {x:e.x+16, y:e.y-6+e.dy, w:e.w-32, h:e.h-12}
      )){
        gameOver();
        return;
      }
    } else if (e.state==='fading'){
      e.alpha -= 0.05;
      e.x -= e.speed;
      if (e.alpha <= 0){
        enemies.splice(i,1);
        kills++;
        continue;
      }
    }

    // remove if way off-screen
    if (e && e.x + e.w < -60) enemies.splice(i,1);
  }

  /* Particles */
  for (let p=particles.length-1;p>=0;p--){
    const pt = particles[p];
    pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.08; pt.life--;
    if (pt.life<=0) particles.splice(p,1);
  }

  /* Fog motion */
  for (const f of fogPuffs){
    f.x += f.dx;
    if (f.x < -f.r) { f.x = canvas.width + f.r; f.y = Math.random()*canvas.height; }
  }

  /* Lightning + Thunder timing */
  if (lightningTimer > 0){
    lightningTimer--;
  } else {
    // trigger lightning
    lightningFlash = 1.0; // start bright
    scheduleLightning();
    try {
      thunderSfx.currentTime = 0;
      thunderSfx.volume = 0.9;
      // Only play if user interacted (same autoplay rule)
      if (audioArmed) thunderSfx.play().catch(()=>{});
    } catch(e){}
  }

  /* HUD */
  scoreEl.textContent = 'Score: ' + Math.floor(score);
  killsEl.textContent = 'Ghosts banished: ' + kills;
}

function draw(){
  // Background (with safe fallback)
  if (bgImg.complete && bgImg.naturalWidth > 0) {
    ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);
  } else {
    const g=ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#0b0f1a'); g.addColorStop(1,'#020307');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // Dark tint
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Bullets
  ctx.fillStyle = 'rgba(255,230,140,1)';
  for (const b of bullets) ctx.fillRect(b.x,b.y,b.w,b.h);

  // Player
  ctx.save();
  ctx.shadowColor = 'rgba(255,255,255,0.15)';
  ctx.shadowBlur = 8;
  if (playerImg.complete && playerImg.naturalWidth>0) ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
  else { ctx.fillStyle='#fff'; ctx.fillRect(player.x,player.y,player.w,player.h); }
  ctx.restore();

  // Enemies (ghosts)
  for (const e of enemies){
    if (!e) continue;
    ctx.save();
    ctx.globalAlpha = Math.max(0, e.alpha ?? 1);
    ctx.shadowColor = 'rgba(150,200,255,0.35)';
    ctx.shadowBlur = 12;
    if (enemyImg.complete && enemyImg.naturalWidth>0) ctx.drawImage(enemyImg, e.x, e.y + e.dy, e.w, e.h);
    else { ctx.fillStyle='#9cf'; ctx.fillRect(e.x, e.y + e.dy, e.w, e.h); }
    ctx.restore();
  }

  // Fog (soft puffs)
  ctx.save();
  for (const f of fogPuffs){
    const radial = ctx.createRadialGradient(f.x, f.y, f.r*0.2, f.x, f.y, f.r);
    radial.addColorStop(0, `rgba(255,255,255,${f.alpha})`);
    radial.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = radial;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // Lightning flash overlay
  if (lightningFlash > 0){
    const intensity = Math.max(0, lightningFlash);
    ctx.fillStyle = `rgba(255,255,255,${0.75*intensity})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // decay rapidly, with little stutter for realism
    lightningFlash *= 0.82;
    if (Math.random()<0.2) lightningFlash *= 0.7;
  }

  // Vignette
  const vg = ctx.createRadialGradient(canvas.width*0.5, canvas.height*0.45, canvas.height*0.2, canvas.width*0.5, canvas.height*0.45, canvas.height*0.8);
  vg.addColorStop(0,'rgba(0,0,0,0)');
  vg.addColorStop(1,'rgba(0,0,0,0.55)');
  ctx.fillStyle = vg; ctx.fillRect(0,0,canvas.width,canvas.height);
}

function loop(){
  if (!running) return;
  update();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  draw();
  requestAnimationFrame(loop);
}

/* ====== Game Over / Restart ====== */
function gameOver(){
  running = false;
  finalScoreEl.textContent = 'Score: ' + Math.floor(score) + '  •  Banished: ' + kills;
  overlay.style.visibility = 'visible';
  try { ambience.pause(); } catch(e){}
}
function restart(){
  enemies = [];
  bullets = [];
  particles = [];
  fogPuffs.forEach(f=>{ f.x = Math.random()*canvas.width; f.y = Math.random()*canvas.height; });
  spawnTimer = 0; score = 0; kills = 0;
  player.x = 100; player.y = GROUND_Y; player.vy = 0; player.jumping = false;
  running = true;
  overlay.style.visibility = 'hidden';
  armAudio();
  loop();
}
restartBtn.addEventListener('click', restart);

/* ====== Start ====== */
initFog();
console.log('Game starting… (images may still be loading)');
loop();
</script>
</body>
</html>
